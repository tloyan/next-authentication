# Database Session Management

### ğŸ’¡ Comprendre les Sessions gÃ©rÃ©es en base de donnÃ©es

## ğŸ“ Tes notes

DÃ©taille ce que tu as appris ici,Â surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Dans les sections prÃ©cÃ©dentes, nous avons implÃ©mentÃ© une gestion des sessions en cookies, câ€™est Ã  dire sans Ã©tat (aucune gestion de la session cÃ´tÃ© serveur).

Seul le client gÃ¨re sa session (_date dâ€™expiration par exemple_), aucune information de session est sauvegardÃ©e cÃ´tÃ© serveur.

Avoir une session gÃ©rÃ©e en base de donnÃ©es cÃ´tÃ© serveur permet de gÃ©rer la fin de sessions, les multisessions etcâ€¦

Pour fonctionner, il faut pouvoir persister les donnÃ©es de sessions en BDD. Pour les besoins de lâ€™exercice, nous avons dÃ©jÃ  des fonctions permettant de gÃ©rer cela.

```tsx
import {addSession, findSession, updateSession, deleteSession} from '@/db/sgbd'

const session = await findSession(sessionId)
const session = await addSession(session)
const session = await updateSession(session)
await deleteSession(sessionId)
```

Pour ne pas confondre ces fonctions de la couche de persistance avec la couche de gestion de sessions, nous les renommerons en `DAO`

```tsx
import {
  addSession as addSessionDao,
  findSession as findSessionDao,
  updateSession as updateSessionDao,
  deleteSession as deleteSessionDao,
} from '@/db/sgbd'

const session = await findSessionDao(sessionId)
const session = await addSessionDao(session)
const session = await updateSessionDao(session)
await deleteSessionDao(sessionId)
```

### Les Cookies ?

- Les cookies sont toujours utiles mais cette fois-ci, aucune information (comme le `userId`) et garder dans les cookies.
- La seule information stockÃ©e et utile est la `sessionId`
- Avec cette information, on pourra retrouver : la `session`, puis le `userId`, puis le `user`

## Exercice

**ğŸ‘¨â€âœˆï¸ Hugo, le chef de projet, demande de pouvoir gÃ©rer 2 types de sessions dans lâ€™application.**

- Les sessions `stateless`(dÃ©jÃ  fait).
- Les sessions gÃ©rÃ©es en BDD (Ã  implÃ©menter).

Nous allons donc avoir les mÃªmes fonctions mais avec des implÃ©mentations diffÃ©rentes

- `createSession`(crÃ©ation de la session : Cookies + BDD)
- `verifySession`
  - DÃ©code la session via les Cookies
  - VÃ©rifie la date dâ€™expiration en BDD (et non basÃ©e sur lâ€™expiration de la date du cookies)
- `deleteSession` : Suppression Cookie + BDD

**ğŸ¶ ImplÃ©mente ces fonctions dans le fichier `session-database.ts` .** Pour simplifier lâ€™exercice, nous avons modifiÃ© les imports de `auth.ts` et `dal.ts` pour quâ€™ils appellent les fonctions de **`session-database.ts`$**

Pour le moment, **`session-database.ts` est un simple `wrapper` qui appelle `session-stateless.ts`**

```tsx
import {
  createSession as createSessionStateLess,
  deleteSession as deleteSessionStateLess,
  verifySession as verifySessionStateless,
} from './session-stateless'

export async function createSession(userId: string) {
  return await createSessionStateLess(userId)
}

export async function verifySession() {
  return await verifySessionStateless()
}

export function deleteSession() {
  return deleteSessionStateLess()
}
```

En conclusion, pour le moment nous avons le mÃªme fonctionnement quâ€™avant (`statless`). Tu vas simplement pouvoir implÃ©menter la session `database` ici sans te prÃ©occuper des imports.

**ğŸ¶ Ã‰dite `session-database.ts` et implÃ©mente la `database` session.**

_PS : Ã‰dite le `.env.local` si tu souhaites lire les donnÃ©es des cookies dans le browser_

```tsx
SESSION_USE_JWT = false
```

_PS2 : Regarde le fichier `db.json` pour analyser les sessions_

```tsx
 "sessions": [
    {
      "sessionId": "1",
      "userId": "1",
      "expiresAt": "2024-07-12T07:19:11.389Z"
    },
    {
      "sessionId": "c89b4c72-81a0-4d1e-85fd-244a4b176543",
      "userId": "2",
      "expiresAt": "2024-07-12T07:32:33.958Z"
    }
```

Fichiers

- `exercise/auth/lib/session-database.ts`

## Bonus

### 1. ğŸš€ Update Session

On peut parfois avoir besoin de mettre Ã  jour la session (Ã©tendre la date dâ€™expiration par exemple) ou invalider la session (cela dÃ©connectera les `users` utilisant la session).

**ğŸ¶ Dans cet exercice, tu vas devoir implÃ©menter `updateSession`.** Pour simplifier lâ€™exercice `updateSession` est dÃ©jÃ  appelÃ© dans `getConnectedUser` de `dal.ts`.

Lâ€™idÃ©e est de mettre Ã  jour la session Ã  chaque fois quâ€™une requÃªte utilisateur arrive.

VoilÃ  les grandes Ã©tapes :

- RÃ©cupÃ©ration et dÃ©cryptage de la session.
- Recalcule dâ€™une nouvelle date dâ€™expiration.

```tsx
const expires = new Date(Date.now() + EXPIRE_TIME)
```

- Recherche de la session en BDD (`findSessionDao`).
- Mise Ã  jour du champ `expiresAt`.
- Mise Ã  jour de la session en BDD (`updateSessionDao`).
- Essaie Ã©galement de mettre Ã  jour le cookie (`expires`).

```tsx
cookies().set('session', session, {
  httpOnly: true,
  secure: true,
  expires,
  sameSite: 'lax',
  path: '/',
})
```

- Constate le problÃ¨me : `Cookies can only be modified in a Server Action or Route Handler`
- Constate le problÃ¨me de boucle (`HMR`) et fait un `build` de prod.

Fichiers

- `exercise/auth/lib/session-database.ts`

### 2. ğŸš€ Session Unique

Si le mÃªme utilisateur se connecte plusieurs fois (sans `logout`), plusieurs sessions seront en BDD. Parfois il est nÃ©cessaire de gÃ©rer les sessions et de sâ€™assurer quâ€™une seule session est gÃ©rÃ©e.

**ğŸ‘¨â€âœˆï¸ Hugo, le chef de projet, te demande dâ€™adapter `createSession` pour ne pas dupliquer les sessions**

Les grandes Ã©tapes.

- VÃ©rifier la prÃ©sence dâ€™une session en BDD : `const sessionByUid = await findSessionByUid(uid)`
  - VÃ©rifier expiration
- Si prÃ©sence, alors ne pas crÃ©er de nouvelle session et mettre Ã  jour la session avec nouvelle date dâ€™expiration
- Sinon crÃ©er une nouvelle session
- Mettre Ã  jour le cookie

### 3. ğŸš€ Session segmentÃ©e par user agent

On peut aussi avoir Ã  gÃ©rer des sessions distinctes par user agent (`Ihpone`, `Ipad`, `Chrome`) etcâ€¦ Ce qui permet dâ€™identifier (et dÃ©connecter) certain appareil.

**ğŸ‘¨â€âœˆï¸ Hugo, le chef de projet, te demande dâ€™adapter `createSession` pour gÃ©rer les sessions par `user` et `userAgent`.**

Les grandes Ã©tapes :

- Identique Ã  prÃ©cÃ©demment mis Ã  part.
- RÃ©cupÃ©ration du `User Agent` via le `header`.

```tsx
const headersList = headers()
const userAgent = headersList.get('User-Agent')

//creation session avec userAgent
await addSessionDao({
  sessionId,
  userId: uid,
  expiresAt: expiresAt.toISOString(),
  userAgent,
})
// Recherche
const sessionByUid = await findSessionByUidUserAgent(uid, userAgent ?? '')
```

- **ğŸ¶ Adapte lâ€™algorithme**

_PS : Supprime les sessions de la BDD pour le `user-agent`._

_PS : Connecte toi avec 2 navigateurs (navigation privÃ©) et expire les dates en BDD pour constater les dÃ©connexions._

`ps : on pourrait affiner les sessions avec IP etc â€¦`

Fichiers

- `exercise/auth/lib/session-database.ts`

## Aller plus loin

ğŸ“‘ Le lien vers la doc [https://nextjs.org/docs/app/api-reference/functions/headers](https://nextjs.org/docs/app/api-reference/functions/headers)

## Ils vont tâ€™aider

- **ğŸ¶ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ğŸ¤– Ash le Robot** : _Ash le Robot te donnera du code utile._
- **ğŸš€ Julia La roquette** : _Julia te donnera des dÃ©fis supplÃ©mentaires._
- **â›ï¸ Hulk le Marteau** : _Quand du code Ã  supprimer est prÃ©sent_
- **ğŸ‘¨â€âœˆï¸ Hugo le chef de projet** : _Va t'aider sur les spÃ©cifications du projet_

## ğŸœ Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20PRO&entry.1430994900=05.Next%20Auth&entry.533578441=08%20Session%20-%20Database).
